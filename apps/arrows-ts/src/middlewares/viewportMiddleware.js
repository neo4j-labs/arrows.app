import { adjustViewport } from '../actions/viewTransformation';
import { Point } from '../model/Point';
import { ViewTransformation } from '../state/ViewTransformation';
import { Vector } from '../model/Vector';
import { tryMoveNode } from '../actions/graph';
import { canvasPadding, computeCanvasSize } from '../model/applicationLayout';
import { getVisualGraph } from '@neo4j-arrows/graphics';
import BoundingBox from '../graphics/utils/BoundingBox';

const observedActionTypes = [
  'NEW_GOOGLE_DRIVE_DIAGRAM',
  'NEW_LOCAL_STORAGE_DIAGRAM',
  'CREATE_NODE',
  'MOVE_NODES',
  'MOVE_NODES_END_DRAG',
  'GETTING_GRAPH_SUCCEEDED',
  'DUPLICATE_NODES_AND_RELATIONSHIPS',
  'DELETE_NODES_AND_RELATIONSHIPS',
  'WINDOW_RESIZED',
  'TOGGLE_INSPECTOR',
  'IMPORT_NODES_AND_RELATIONSHIPS',
];

export const nodeMovedOutsideCanvas = (
  visualGraph,
  canvasSize,
  viewTransformation,
  action
) => {
  const node = visualGraph.nodes[action.nodePositions[0].nodeId];
  const nodeBoundingBox = node
    .boundingBox()
    .scale(viewTransformation.scale)
    .translate(viewTransformation.offset);

  const canvasBoundingBox = new BoundingBox(
    canvasPadding,
    canvasSize.width - canvasPadding,
    canvasPadding,
    canvasSize.height - canvasPadding
  );

  return !canvasBoundingBox.containsBoundingBox(nodeBoundingBox);
};

export const calculateViewportTranslation = (visualGraph, canvasSize) => {
  const boundingBox = visualGraph.boundingBox();

  if (boundingBox) {
    let visualsWidth = boundingBox.right - boundingBox.left;
    let visualsHeight = boundingBox.bottom - boundingBox.top;
    let visualsCenter = new Point(
      (boundingBox.right + boundingBox.left) / 2,
      (boundingBox.bottom + boundingBox.top) / 2
    );

    const viewportWidth = canvasSize.width - canvasPadding * 2;
    const viewportHeight = canvasSize.height - canvasPadding * 2;
    const viewportCenter = new Point(
      canvasPadding + viewportWidth / 2,
      canvasPadding + viewportHeight / 2
    );

    let scale = Math.min(
      1,
      Math.min(viewportHeight / visualsHeight, viewportWidth / visualsWidth)
    );

    if (scale !== 1) {
      visualsCenter = new Point(
        (scale * (boundingBox.right + boundingBox.left)) / 2,
        (scale * (boundingBox.bottom + boundingBox.top)) / 2
      );
    }

    return {
      scale,
      translateVector: viewportCenter.vectorFrom(visualsCenter),
    };
  } else {
    return {};
  }
};

export const viewportMiddleware = (store) => (next) => (action) => {
  const result = next(action);

  if (!action.autoGenerated && observedActionTypes.includes(action.type)) {
    const state = store.getState();
    const { applicationLayout, viewTransformation, mouse } = state;
    const canvasSize = computeCanvasSize(applicationLayout);
    const visualGraph = getVisualGraph(state);

    if (action.type === 'MOVE_NODES') {
      const shouldScaleUp = nodeMovedOutsideCanvas(
        visualGraph,
        canvasSize,
        viewTransformation,
        action
      );
      if (shouldScaleUp) {
        let { scale, translateVector } = calculateViewportTranslation(
          visualGraph,
          canvasSize
        );

        store.dispatch(
          adjustViewport(scale, translateVector.dx, translateVector.dy)
        );

        if (mouse.mouseToNodeVector) {
          const newViewTransformation = new ViewTransformation(
            scale,
            new Vector(translateVector.dx, translateVector.dy)
          );
          const mousePositionInGraph = newViewTransformation.inverse(
            action.newMousePosition || mouse.mousePosition
          );

          const expectedNodePositionbyMouse = mousePositionInGraph.translate(
            mouse.mouseToNodeVector.scale(viewTransformation.scale)
          );
          const differenceVector = expectedNodePositionbyMouse.vectorFrom(
            action.nodePositions[0].position
          );

          if (differenceVector.distance() > 1) {
            window.requestAnimationFrame(() =>
              store.dispatch(
                tryMoveNode({
                  nodeId: action.nodePositions[0].nodeId,
                  oldMousePosition: action.oldMousePosition,
                  newMousePosition: null,
                  forcedNodePosition: expectedNodePositionbyMouse,
                })
              )
            );
          }
        }
      }
    } else {
      let { scale, translateVector } = calculateViewportTranslation(
        visualGraph,
        canvasSize
      );

      if (scale) {
        if (action.type === 'MOVE_NODES_END_DRAG') {
          if (scale > viewTransformation.scale) {
            let currentStep = 0;
            let duration = 1000;
            let fps = 60;

            const targetViewTransformation = new ViewTransformation(
              scale,
              new Vector(translateVector.dx, translateVector.dy)
            );
            const { scaleTable, panningTable } = calculateTransformationTable(
              viewTransformation,
              targetViewTransformation,
              duration / fps
            );

            const animateScale = () => {
              setTimeout(() => {
                const nextScale = scaleTable[currentStep];
                const nextPan = panningTable[currentStep];

                store.dispatch(
                  adjustViewport(nextScale, nextPan.dx, nextPan.dy)
                );

                currentStep++;
                if (currentStep < scaleTable.length) {
                  window.requestAnimationFrame(animateScale);
                }
              }, 1000 / fps);
            };

            window.requestAnimationFrame(animateScale);
          }
        } else {
          store.dispatch(
            adjustViewport(scale, translateVector.dx, translateVector.dy)
          );
        }
      }
    }
  }

  return result;
};

const calculateTransformationTable = (
  currentViewTransformation,
  targetViewTransformation,
  totalSteps
) => {
  let lastScale = currentViewTransformation.scale;
  const targetScale = targetViewTransformation.scale;
  const scaleByStep = (targetScale - lastScale) / totalSteps;

  let lastPan = {
    dx: currentViewTransformation.offset.dx,
    dy: currentViewTransformation.offset.dy,
  };
  const panByStep = {
    dx: (targetViewTransformation.offset.dx - lastPan.dx) / totalSteps,
    dy: (targetViewTransformation.offset.dy - lastPan.dy) / totalSteps,
  };

  const scaleTable = [];
  const panningTable = [];
  let stepIndex = 0;

  while (stepIndex < totalSteps - 1) {
    lastScale += scaleByStep;
    lastPan = {
      dx: lastPan.dx + panByStep.dx,
      dy: lastPan.dy + panByStep.dy,
    };

    scaleTable.push(lastScale);
    panningTable.push(lastPan);

    stepIndex++;
  }

  // because of decimal figures does not sum up to exact number
  scaleTable.push(targetViewTransformation.scale);
  panningTable.push(targetViewTransformation.offset);

  return {
    scaleTable,
    panningTable,
  };
};
