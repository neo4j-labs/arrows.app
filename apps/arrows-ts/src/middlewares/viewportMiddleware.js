import {adjustViewport} from "../actions/viewTransformation"
import {Point} from "../model-old/Point"
import {ViewTransformation} from "../state/ViewTransformation";
import {Vector} from "../model-old/Vector";
import {tryMoveNode} from "../actions/graph";
import {canvasPadding, computeCanvasSize} from "../model-old/applicationLayout";
import {getVisualGraph} from "../selectors/index";
import BoundingBox from "../graphics/utils/BoundingBox";

const observedActionTypes = [
  'NEW_GOOGLE_DRIVE_DIAGRAM',
  'NEW_LOCAL_STORAGE_DIAGRAM',
  'CREATE_NODE',
  'MOVE_NODES',
  'MOVE_NODES_END_DRAG',
  'GETTING_GRAPH_SUCCEEDED',
  'DUPLICATE_NODES_AND_RELATIONSHIPS',
  'DELETE_NODES_AND_RELATIONSHIPS',
  'WINDOW_RESIZED',
  'TOGGLE_INSPECTOR',
  'IMPORT_NODES_AND_RELATIONSHIPS'
]

export const nodeMovedOutsideCanvas = (visualGraph, canvasSize, viewTransformation, action) => {
  const node = visualGraph.nodes[action.nodePositions[0].nodeId]
  const nodeBoundingBox = node.boundingBox()
    .scale(viewTransformation.scale)
    .translate(viewTransformation.offset)

  const canvasBoundingBox = new BoundingBox(
    canvasPadding,
    canvasSize.width - canvasPadding,
    canvasPadding,
    canvasSize.height - canvasPadding
  )

  return !canvasBoundingBox.containsBoundingBox(nodeBoundingBox)
}

export const calculateViewportTranslation = (visualGraph, canvasSize) => {
  const boundingBox = visualGraph.boundingBox()

  if (boundingBox) {
    let visualsWidth = (boundingBox.right - boundingBox.left)
    let visualsHeight = (boundingBox.bottom - boundingBox.top)
    let visualsCenter = new Point((boundingBox.right + boundingBox.left) / 2, (boundingBox.bottom + boundingBox.top) / 2)

    const viewportWidth = canvasSize.width - canvasPadding * 2
    const viewportHeight = canvasSize.height - canvasPadding * 2
    const viewportCenter = new Point(canvasPadding + viewportWidth / 2, canvasPadding + viewportHeight / 2)

    let scale = Math.min(1, Math.min(viewportHeight / visualsHeight, viewportWidth / visualsWidth))

    if (scale !== 1) {
      visualsCenter = new Point(scale * (boundingBox.right + boundingBox.left) / 2, scale * (boundingBox.bottom + boundingBox.top) / 2)
    }

    return {
      scale,
      translateVector: viewportCenter.vectorFrom(visualsCenter)
    }
  } else {
    return {}
  }
}

export const viewportMiddleware = store => next => action => {
  const result = next(action)

  if (!action.autoGenerated && observedActionTypes.includes(action.type)) {
    const state = store.getState()
    const { applicationLayout, viewTransformation, mouse } = state
    const canvasSize = computeCanvasSize(applicationLayout)
    const visualGraph = getVisualGraph(state)

    if (action.type === 'MOVE_NODES') {
      const shouldScaleUp = nodeMovedOutsideCanvas(visualGraph, canvasSize, viewTransformation, action)
      if (shouldScaleUp) {
        let { scale, translateVector } = calculateViewportTranslation(visualGraph, canvasSize)

        store.dispatch(adjustViewport(scale, translateVector.dx, translateVector.dy))

        if (mouse.mouseToNodeVector) {
          const newViewTransformation = new ViewTransformation(scale, new Vector(translateVector.dx, translateVector.dy))
          const mousePositionInGraph = newViewTransformation.inverse(action.newMousePosition || mouse.mousePosition)

          const expectedNodePositionbyMouse = mousePositionInGraph.translate(mouse.mouseToNodeVector.scale(viewTransformation.scale))
          const differenceVector = expectedNodePositionbyMouse.vectorFrom(action.nodePositions[0].position)

          if (differenceVector.distance() > 1) {
            window.requestAnimationFrame(() => store.dispatch(tryMoveNode({
              nodeId: action.nodePositions[0].nodeId,
              oldMousePosition: action.oldMousePosition,
              newMousePosition: null,
              forcedNodePosition: expectedNodePositionbyMouse
            })))
          }
        }
      }
    } else {
      let { scale, translateVector } = calculateViewportTranslation(visualGraph, canvasSize)

      if (scale) {
       if (action.type === 'MOVE_NODES_END_DRAG') {
          if (scale > viewTransformation.scale) {
            let currentStep = 0
            let duration    = 1000
            let fps         = 60

            const targetViewTransformation = new ViewTransformation(scale, new Vector(translateVector.dx, translateVector.dy))
            const { scaleTable, panningTable } = calculateTransformationTable(viewTransformation, targetViewTransformation, duration / fps)

            const animateScale = () => {
              setTimeout(() => {
                const nextScale = scaleTable[currentStep]
                const nextPan = panningTable[currentStep]

                store.dispatch(adjustViewport(nextScale, nextPan.dx, nextPan.dy))

                currentStep++
                if (currentStep < scaleTable.length) {
                  window.requestAnimationFrame(animateScale)
                }
              }, 1000 / fps)
            }

            window.requestAnimationFrame(animateScale)
          }
        } else {
          store.dispatch(adjustViewport(scale, translateVector.dx, translateVector.dy))
        }
      }
    }
  }

  return result
}

const calculateTransformationTable = (currentViewTransformation, targetViewTransformation, totalSteps) => {
  let lastScale = currentViewTransformation.scale
  const targetScale = targetViewTransformation.scale
  const scaleByStep = (targetScale - lastScale) / totalSteps

  let lastPan = {
    dx: currentViewTransformation.offset.dx,
    dy: currentViewTransformation.offset.dy
  }
  const panByStep = {
    dx: (targetViewTransformation.offset.dx - lastPan.dx) / totalSteps,
    dy: (targetViewTransformation.offset.dy - lastPan.dy) / totalSteps
  }

  const scaleTable = []
  const panningTable = []
  let stepIndex = 0

  while (stepIndex < totalSteps - 1) {
    lastScale += scaleByStep
    lastPan = {
      dx: lastPan.dx + panByStep.dx,
      dy: lastPan.dy + panByStep.dy
    }

    scaleTable.push(lastScale)
    panningTable.push(lastPan)

    stepIndex++
  }

  // because of decimal figures does not sum up to exact number
  scaleTable.push(targetViewTransformation.scale)
  panningTable.push(targetViewTransformation.offset)

  return  {
    scaleTable,
    panningTable
  }
}
